// Ticket Service - Simulates database operations using localStorage
// Provides full CRUD operations for support tickets across all support tabs

import { brandConfig } from '../config/brandConfig';
import { intelligentRoutingService } from './intelligentRoutingService';

export interface ISupportTicket {
  id: string;
  ticketNumber: string; // Human-readable ticket number like #ST-1234
  title: string;
  description: string;
  category: 'technical' | 'billing' | 'feature_request' | 'bug_report' | 'ai_support' | 'general';
  type?: 'false_alarm' | 'training_request' | 'interpretation_help' | 'camera_setup' | 'ai_config';
  priority: 'critical' | 'high' | 'medium' | 'low';
  status: 'open' | 'in_progress' | 'pending' | 'resolved' | 'closed';
  clientId: string;
  clientName: string;
  clientEmail: string;
  assignedTo?: string;
  assignedToName?: string;
  createdAt: string;
  updatedAt: string;
  resolvedAt?: string;
  estimatedResolution?: string;
  actualResolution?: string;
  customerSatisfactionRating?: number; // 1-5 scale
  tags: string[];
  attachments?: ITicketAttachment[];
  comments: ITicketComment[];
  aiMetadata?: {
    confidence?: number;
    alertId?: string;
    cameraId?: string;
    falseAlarmType?: string;
    sourceSystem?: string;
    autoGenerated?: boolean;
    [key: string]: any; // Allow additional AI metadata fields
  };
}

export interface ITicketAttachment {
  id: string;
  name: string;
  url: string;
  type: 'image' | 'video' | 'document';
  size: number;
  uploadedAt: string;
}

export interface ITicketComment {
  id: string;
  author: string;
  authorRole: string;
  message: string;
  isInternal: boolean; // Internal notes vs customer-facing
  createdAt: string;
}

export interface ITicketFilters {
  status?: string[];
  priority?: string[];
  category?: string[];
  assignedTo?: string;
  clientId?: string;
  dateRange?: {
    start: string;
    end: string;
  };
  searchTerm?: string;
}

export interface ITicketStats {
  total: number;
  open: number;
  inProgress: number;
  resolved: number;
  closed: number;
  avgResponseTime: string;
  avgResolutionTime: string;
  customerSatisfaction: number;
  firstCallResolution: number;
  byCategory: Record<string, number>;
  byPriority: Record<string, number>;
  todaysTickets: number;
  thisWeekTickets: number;
  thisMonthTickets: number;
}

class TicketService {
  private readonly STORAGE_KEY = 'onebarn_support_tickets';
  private readonly COUNTER_KEY = 'onebarn_ticket_counter';

  // Initialize with sample data if no tickets exist
  private initializeSampleData(): void {
    const existingTickets = localStorage.getItem(this.STORAGE_KEY);
    if (!existingTickets) {
      const sampleTickets = this.generateSampleTickets();
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(sampleTickets));
      localStorage.setItem(this.COUNTER_KEY, '1250'); // Start counter at realistic number
    }
  }

  private generateSampleTickets(): ISupportTicket[] {
    const now = new Date();
    const tickets: ISupportTicket[] = [];

    // Sample ticket data with realistic scenarios
    const sampleData = [
      {
        title: 'Camera feed not loading in stall 12',
        description: 'The live camera feed for stall 12 has been showing a black screen since this morning. Horse owner is concerned about monitoring their mare during foaling season.',
        category: 'technical' as const,
        priority: 'high' as const,
        status: 'in_progress' as const,
        clientName: 'Sarah Johnson',
        clientEmail: 'sarah.johnson@email.com',
        assignedToName: 'Enhanced Support Staff',
        tags: ['camera', 'livestream', 'urgent']
      },
      {
        title: 'Billing discrepancy for December services',
        description: 'Client is questioning charges for additional training sessions that were not requested. Need to review billing records and provide explanation.',
        category: 'billing' as const,
        priority: 'medium' as const,
        status: 'open' as const,
        clientName: 'Mike Chen',
        clientEmail: 'mike.chen@email.com',
        tags: ['billing', 'training', 'dispute']
      },
      {
        title: 'AI false alarm - Horse playing detected as distress',
        description: 'AI system flagged normal horse play behavior as potential distress. Owner received unnecessary alert at 3 AM. Need to adjust AI sensitivity for this horse.',
        category: 'ai_support' as const,
        type: 'false_alarm' as const,
        priority: 'medium' as const,
        status: 'pending' as const,
        clientName: 'Lisa Rodriguez',
        clientEmail: 'lisa.rodriguez@email.com',
        assignedToName: 'Enhanced Support Staff',
        tags: ['ai', 'false-alarm', 'behavior-analysis'],
        aiMetadata: {
          confidence: 87,
          alertId: 'ALT-2024-001234',
          cameraId: 'CAM-STALL-08',
          falseAlarmType: 'normal_play_behavior'
        }
      },
      {
        title: 'Request for mobile app push notifications',
        description: 'Would like to receive push notifications on mobile app when AI detects potential health issues with horses.',
        category: 'feature_request' as const,
        priority: 'low' as const,
        status: 'open' as const,
        clientName: 'David Thompson',
        clientEmail: 'david.thompson@email.com',
        tags: ['mobile', 'notifications', 'enhancement']
      },
      {
        title: 'Training request: Understanding AI health alerts',
        description: 'New horse owner needs training on how to interpret AI health monitoring alerts and when to take immediate action.',
        category: 'ai_support' as const,
        type: 'training_request' as const,
        priority: 'medium' as const,
        status: 'open' as const,
        clientName: 'Jennifer Martinez',
        clientEmail: 'jennifer.martinez@email.com',
        tags: ['training', 'ai', 'health-monitoring', 'new-client']
      },
      {
        title: 'Camera setup assistance needed',
        description: 'Client needs help positioning camera for optimal AI monitoring coverage of new paddock area.',
        category: 'ai_support' as const,
        type: 'camera_setup' as const,
        priority: 'medium' as const,
        status: 'resolved' as const,
        clientName: 'Robert Wilson',
        clientEmail: 'robert.wilson@email.com',
        assignedToName: 'Enhanced Support Staff',
        tags: ['camera', 'setup', 'paddock', 'ai-coverage'],
        customerSatisfactionRating: 5,
        resolvedAt: new Date(now.getTime() - 86400000).toISOString() // Yesterday
      },
      // ESCALATED TECHNICAL TICKETS FOR IT MANAGER
      {
        title: 'ðŸš¨ ESCALATED: AI System Multiple False Positives',
        description: 'ESCALATED FROM SUPPORT: AI system generating excessive false positive alerts across multiple stalls. Camera firmware update may have caused calibration issues. Requires immediate technical intervention to prevent client complaints.',
        category: 'ai_support' as const,
        type: 'false_alarm' as const,
        priority: 'critical' as const,
        status: 'open' as const,
        clientName: 'Sarah Johnson',
        clientEmail: 'sarah@willowcreekstables.com',
        assignedTo: 'it_manager_001',
        assignedToName: 'IT Manager',
        tags: ['escalated', 'ai-alert', 'false-positive', 'camera-firmware', 'critical'],
        aiMetadata: {
          confidence: 45,
          alertId: 'AI-ALERT-20240115-093015',
          cameraId: 'CAM-STALL-12',
          falseAlarmType: 'movement_detection'
        }
      },
      {
        title: 'ðŸ”§ ESCALATED: Database Performance Degradation',
        description: 'ESCALATED FROM SUPPORT: System experiencing slow query response times affecting real-time AI processing. Multiple clients reporting delayed notifications and camera feed lag.',
        category: 'technical' as const,
        priority: 'high' as const,
        status: 'in_progress' as const,
        clientName: 'Multiple Clients',
        clientEmail: 'system@onebarn.com',
        assignedTo: 'it_manager_001',
        assignedToName: 'IT Manager',
        tags: ['escalated', 'database', 'performance', 'system-wide']
      },
      {
        title: 'âš ï¸ ESCALATED: Camera Network Infrastructure Issue',
        description: 'ESCALATED FROM SUPPORT: 6 cameras across facility experiencing intermittent connectivity issues. Network infrastructure may need upgrade or configuration changes.',
        category: 'technical' as const,
        type: 'camera_setup' as const,
        priority: 'high' as const,
        status: 'open' as const,
        clientName: 'Facility Wide',
        clientEmail: 'system@onebarn.com',
        assignedTo: 'it_manager_001',
        assignedToName: 'IT Manager',
        tags: ['escalated', 'network', 'cameras', 'infrastructure', 'connectivity']
      }
    ];

    sampleData.forEach((sample, index) => {
      const ticketId = `ticket_${Date.now()}_${index}`;
      const ticketNumber = `#ST-${1234 + index}`;
      const createdAt = new Date(now.getTime() - (index * 3600000 * 2)).toISOString(); // Spread over last few hours
      
      tickets.push({
        id: ticketId,
        ticketNumber,
        title: sample.title,
        description: sample.description,
        category: sample.category,
        type: sample.type,
        priority: sample.priority,
        status: sample.status,
        clientId: `client_${sample.clientEmail.split('@')[0]}`,
        clientName: sample.clientName,
        clientEmail: sample.clientEmail,
        assignedTo: sample.assignedTo || (sample.assignedToName ? 'support_staff_001' : undefined),
        assignedToName: sample.assignedToName,
        createdAt,
        updatedAt: createdAt,
        resolvedAt: sample.resolvedAt,
        customerSatisfactionRating: sample.customerSatisfactionRating,
        tags: sample.tags,
        comments: [
          {
            id: `comment_${ticketId}_initial`,
            author: sample.clientName,
            authorRole: 'client',
            message: sample.description,
            isInternal: false,
            createdAt
          }
        ],
        aiMetadata: sample.aiMetadata
      });
    });

    return tickets;
  }

  private getNextTicketNumber(): string {
    const counter = parseInt(localStorage.getItem(this.COUNTER_KEY) || '1000');
    const nextCounter = counter + 1;
    localStorage.setItem(this.COUNTER_KEY, nextCounter.toString());
    return `#ST-${nextCounter}`;
  }

  private saveTickets(tickets: ISupportTicket[]): void {
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(tickets));
  }

  private loadTickets(): ISupportTicket[] {
    this.initializeSampleData();
    const ticketsData = localStorage.getItem(this.STORAGE_KEY);
    return ticketsData ? JSON.parse(ticketsData) : [];
  }

  // Create a new ticket
  public async createTicket(ticketData: Partial<ISupportTicket>): Promise<ISupportTicket> {
    const tickets = this.loadTickets();
    const now = new Date().toISOString();
    
    // Create initial ticket without assignment
    const newTicket: ISupportTicket = {
      id: `ticket_${Date.now()}_${Math.random().toString(36).substring(2)}`,
      ticketNumber: this.getNextTicketNumber(),
      title: ticketData.title || 'Untitled Ticket',
      description: ticketData.description || '',
      category: ticketData.category || 'general',
      type: ticketData.type,
      priority: ticketData.priority || 'medium',
      status: 'open',
      clientId: ticketData.clientId || `client_${Date.now()}`,
      clientName: ticketData.clientName || 'Unknown Client',
      clientEmail: ticketData.clientEmail || 'unknown@email.com',
      assignedTo: ticketData.assignedTo, // May be undefined for auto-routing
      assignedToName: ticketData.assignedToName, // May be undefined for auto-routing
      createdAt: now,
      updatedAt: now,
      tags: ticketData.tags || [],
      comments: [
        {
          id: `comment_${Date.now()}_initial`,
          author: ticketData.clientName || 'System',
          authorRole: 'client',
          message: ticketData.description || 'Ticket created',
          isInternal: false,
          createdAt: now
        }
      ],
      aiMetadata: ticketData.aiMetadata
    };

    // AUTO-ROUTE TICKET if not manually assigned
    if (!newTicket.assignedTo && !newTicket.assignedToName) {
      try {
        console.log('ðŸŽ¯ Auto-routing ticket:', newTicket.ticketNumber);
        
        // Use intelligent routing service to determine assignment
        const routingResult = await intelligentRoutingService.testRoutingDecision(newTicket);
        
        if (routingResult.routing) {
          newTicket.assignedTo = routingResult.routing.assignedTo;
          newTicket.assignedToName = routingResult.routing.assignedToName;
          newTicket.estimatedResolution = `${routingResult.routing.estimatedResolutionTime} minutes`;
          
          // Update priority if routing suggests a different one
          if (routingResult.routing.suggestedPriority) {
            newTicket.priority = routingResult.routing.suggestedPriority;
          }
          
          // Add routing metadata to AI metadata
          newTicket.aiMetadata = {
            ...newTicket.aiMetadata,
            routingConfidence: routingResult.routing.confidence,
            routingReason: routingResult.routing.routingReason,
            sentiment: routingResult.analysis.sentiment,
            technicalComplexity: routingResult.analysis.technicalComplexity,
            autoRouted: true,
            routedAt: now
          };
          
          // Add internal comment about routing
          newTicket.comments.push({
            id: `comment_${Date.now()}_routing`,
            author: 'AI Routing System',
            authorRole: 'system',
            message: `ðŸŽ¯ Auto-assigned to ${newTicket.assignedToName}. Reason: ${routingResult.routing.routingReason}. Confidence: ${Math.round(routingResult.routing.confidence * 100)}%`,
            isInternal: true,
            createdAt: now
          });
          
          console.log(`âœ… Ticket ${newTicket.ticketNumber} routed to ${newTicket.assignedToName} (${Math.round(routingResult.routing.confidence * 100)}% confidence)`);
        } else {
          console.warn('âŒ Routing failed, using default assignment');
          this.applyDefaultRouting(newTicket);
        }
      } catch (error) {
        console.error('âŒ Auto-routing failed:', error);
        this.applyDefaultRouting(newTicket);
      }
    }

    tickets.push(newTicket);
    this.saveTickets(tickets);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 100));
    return newTicket;
  }

  // Apply default routing rules when intelligent routing fails
  private applyDefaultRouting(ticket: ISupportTicket): void {
    // Default routing rules based on category
    const defaultRouting = {
      'technical': { assignedTo: 'it_manager_001', assignedToName: 'IT Manager' },
      'ai_support': { assignedTo: 'it_manager_001', assignedToName: 'IT Manager' },
      'billing': { assignedTo: 'manager_001', assignedToName: 'Support Manager' },
      'feature_request': { assignedTo: 'manager_001', assignedToName: 'Support Manager' },
      'bug_report': { assignedTo: 'it_manager_001', assignedToName: 'IT Manager' },
      'general': { assignedTo: 'support_001', assignedToName: 'Enhanced Support Staff' }
    };
    
    const routing = defaultRouting[ticket.category] || defaultRouting['general'];
    ticket.assignedTo = routing.assignedTo;
    ticket.assignedToName = routing.assignedToName;
    
    // Add fallback routing comment
    ticket.comments.push({
      id: `comment_${Date.now()}_fallback`,
      author: 'Routing System',
      authorRole: 'system',
      message: `ðŸ“‹ Assigned to ${ticket.assignedToName} based on category: ${ticket.category}`,
      isInternal: true,
      createdAt: new Date().toISOString()
    });
    
    console.log(`ðŸ“‹ Ticket ${ticket.ticketNumber} assigned to ${ticket.assignedToName} via default routing`);
  }

  // Get all tickets with optional filtering
  public async getTickets(filters?: ITicketFilters): Promise<ISupportTicket[]> {
    let tickets = this.loadTickets();
    
    if (filters) {
      tickets = tickets.filter(ticket => {
        // Status filter
        if (filters.status && filters.status.length > 0) {
          if (!filters.status.includes(ticket.status)) return false;
        }
        
        // Priority filter
        if (filters.priority && filters.priority.length > 0) {
          if (!filters.priority.includes(ticket.priority)) return false;
        }
        
        // Category filter
        if (filters.category && filters.category.length > 0) {
          if (!filters.category.includes(ticket.category)) return false;
        }
        
        // Assigned to filter
        if (filters.assignedTo) {
          if (ticket.assignedTo !== filters.assignedTo) return false;
        }
        
        // Client filter
        if (filters.clientId) {
          if (ticket.clientId !== filters.clientId) return false;
        }
        
        // Search term filter
        if (filters.searchTerm) {
          const searchLower = filters.searchTerm.toLowerCase();
          const searchableText = [
            ticket.title,
            ticket.description,
            ticket.clientName,
            ticket.ticketNumber,
            ...ticket.tags
          ].join(' ').toLowerCase();
          
          if (!searchableText.includes(searchLower)) return false;
        }
        
        // Date range filter
        if (filters.dateRange) {
          const ticketDate = new Date(ticket.createdAt);
          const startDate = new Date(filters.dateRange.start);
          const endDate = new Date(filters.dateRange.end);
          
          if (ticketDate < startDate || ticketDate > endDate) return false;
        }
        
        return true;
      });
    }
    
    // Sort by creation date (newest first)
    tickets.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 150));
    return tickets;
  }

  // Get a single ticket by ID
  public async getTicket(id: string): Promise<ISupportTicket | null> {
    const tickets = this.loadTickets();
    const ticket = tickets.find(t => t.id === id);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 100));
    return ticket || null;
  }

  // Update a ticket
  public async updateTicket(id: string, updates: Partial<ISupportTicket>): Promise<ISupportTicket | null> {
    const tickets = this.loadTickets();
    const ticketIndex = tickets.findIndex(t => t.id === id);
    
    if (ticketIndex === -1) return null;
    
    const updatedTicket = {
      ...tickets[ticketIndex],
      ...updates,
      updatedAt: new Date().toISOString(),
      // Special handling for status changes
      resolvedAt: updates.status === 'resolved' && tickets[ticketIndex].status !== 'resolved' 
        ? new Date().toISOString() 
        : tickets[ticketIndex].resolvedAt
    };
    
    tickets[ticketIndex] = updatedTicket;
    this.saveTickets(tickets);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 120));
    return updatedTicket;
  }

  // Add a comment to a ticket
  public async addComment(ticketId: string, comment: Omit<ITicketComment, 'id' | 'createdAt'>): Promise<ITicketComment> {
    const tickets = this.loadTickets();
    const ticketIndex = tickets.findIndex(t => t.id === ticketId);
    
    if (ticketIndex === -1) throw new Error('Ticket not found');
    
    const newComment: ITicketComment = {
      id: `comment_${Date.now()}_${Math.random().toString(36).substring(2)}`,
      ...comment,
      createdAt: new Date().toISOString()
    };
    
    tickets[ticketIndex].comments.push(newComment);
    tickets[ticketIndex].updatedAt = new Date().toISOString();
    
    this.saveTickets(tickets);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 100));
    return newComment;
  }

  // Get ticket statistics
  public async getTicketStats(): Promise<ITicketStats> {
    const tickets = this.loadTickets();
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const thisWeek = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
    const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    
    const stats: ITicketStats = {
      total: tickets.length,
      open: tickets.filter(t => t.status === 'open').length,
      inProgress: tickets.filter(t => t.status === 'in_progress').length,
      resolved: tickets.filter(t => t.status === 'resolved').length,
      closed: tickets.filter(t => t.status === 'closed').length,
      avgResponseTime: '2.3 hours',
      avgResolutionTime: '18.5 hours',
      customerSatisfaction: 4.2,
      firstCallResolution: 89,
      byCategory: {},
      byPriority: {},
      todaysTickets: tickets.filter(t => new Date(t.createdAt) >= today).length,
      thisWeekTickets: tickets.filter(t => new Date(t.createdAt) >= thisWeek).length,
      thisMonthTickets: tickets.filter(t => new Date(t.createdAt) >= thisMonth).length
    };
    
    // Calculate category breakdown
    tickets.forEach(ticket => {
      stats.byCategory[ticket.category] = (stats.byCategory[ticket.category] || 0) + 1;
    });
    
    // Calculate priority breakdown
    tickets.forEach(ticket => {
      stats.byPriority[ticket.priority] = (stats.byPriority[ticket.priority] || 0) + 1;
    });
    
    // Calculate customer satisfaction from resolved tickets with ratings
    const ratedTickets = tickets.filter(t => t.customerSatisfactionRating);
    if (ratedTickets.length > 0) {
      const avgRating = ratedTickets.reduce((sum, t) => sum + (t.customerSatisfactionRating || 0), 0) / ratedTickets.length;
      stats.customerSatisfaction = Math.round(avgRating * 10) / 10;
    }
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 200));
    return stats;
  }

  // Delete a ticket (soft delete by changing status)
  public async deleteTicket(id: string): Promise<boolean> {
    const tickets = this.loadTickets();
    const ticketIndex = tickets.findIndex(t => t.id === id);
    
    if (ticketIndex === -1) return false;
    
    // Soft delete - mark as closed instead of removing
    tickets[ticketIndex].status = 'closed';
    tickets[ticketIndex].updatedAt = new Date().toISOString();
    
    this.saveTickets(tickets);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 100));
    return true;
  }

  // Assign ticket to support staff
  public async assignTicket(ticketId: string, assignedTo: string, assignedToName: string): Promise<ISupportTicket | null> {
    return this.updateTicket(ticketId, { assignedTo, assignedToName });
  }

  // Close ticket with satisfaction rating
  public async closeTicket(ticketId: string, satisfactionRating?: number): Promise<ISupportTicket | null> {
    const updates: Partial<ISupportTicket> = { 
      status: 'resolved' as const,
      resolvedAt: new Date().toISOString()
    };
    
    if (satisfactionRating) {
      updates.customerSatisfactionRating = satisfactionRating;
    }
    
    return this.updateTicket(ticketId, updates);
  }

  // Get tickets for a specific client
  public async getClientTickets(clientId: string): Promise<ISupportTicket[]> {
    return this.getTickets({ clientId });
  }

  // Get tickets assigned to a specific support staff member
  public async getAssignedTickets(assignedTo: string): Promise<ISupportTicket[]> {
    return this.getTickets({ assignedTo });
  }

  // Search tickets
  public async searchTickets(searchTerm: string): Promise<ISupportTicket[]> {
    return this.getTickets({ searchTerm });
  }
}

// Export singleton instance
export const ticketService = new TicketService(); 